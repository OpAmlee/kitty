#:      ╦╔═╦╔╦╗╔╦╗╦ ╦  ╔═╗╔═╗╔╗╔╔╦╗╔═╗  ╔═╗╔═╗╔╗╔╔═╗╦╔═╗
#:      ╠╩╗║ ║  ║ ╚╦╝  ╠╣ ║ ║║║║ ║ ╚═╗  ║  ║ ║║║║╠╣ ║║ ╦
#:      ╩ ╩╩ ╩  ╩  ╩   ╚  ╚═╝╝╚╝ ╩ ╚═╝  ╚═╝╚═╝╝╚╝╚  ╩╚═╝

#: to see supported fonts $ kitty list-fonts


 font_family      FreeMono
 bold_font        FreeMono Bold
 italic_font      FreeMono Bold Oblique
 bold_italic_font FreeMono Oblique    



font_size 14.0

#: Font size (in pts)

force_ltr no

#: kitty does not support BIDI (bidirectional text), however, for RTL
#: scripts, words are automatically displayed in RTL. That is to say,
#: in an RTL script, the words "HELLO WORLD" display in kitty as
#: "WORLD HELLO", and if you try to select a substring of an RTL-
#: shaped string, you will get the character that would be there had
#: the the string been LTR. For example, assuming the Hebrew word
#: ירושלים, selecting the character that on the screen appears to be ם
#: actually writes into the selection buffer the character י.  kitty's
#: default behavior is useful in conjunction with a filter to reverse
#: the word order, however, if you wish to manipulate RTL glyphs, it
#: can be very challenging to work with, so this option is provided to
#: turn it off. Furthermore, this option can be used with the command
#: line program GNU FriBidi
#: <https://github.com/fribidi/fribidi#executable> to get BIDI
#: support, because it will force kitty to always treat the text as
#: LTR, which FriBidi expects for terminals.

adjust_line_height  0
adjust_column_width 0

#: Change the size of each character cell kitty renders. You can use
#: either numbers, which are interpreted as pixels or percentages
#: (number followed by %), which are interpreted as percentages of the
#: unmodified values. You can use negative pixels or percentages less
#: than 100% to reduce sizes (but this might cause rendering
#: artifacts).

adjust_baseline 0

#: Adjust the vertical alignment of text (the height in the cell at
#: which text is positioned). You can use either numbers, which are
#: interpreted as pixels or percentages (number followed by %), which
#: are interpreted as the percentage of the line height. A positive
#: value moves the baseline up, and a negative value moves them down.
#: The underline and strikethrough positions are adjusted accordingly.

 #: Map the specified Unicode codepoints to a particular font. Useful
#: if you need special rendering for some symbols, such as for
#: Powerline. Avoids the need for patched fonts. Each Unicode code
#: point is specified in the form `U+<code point in hexadecimal>`. You
#: can specify multiple code points, separated by commas and ranges
#: separated by hyphens. This option can be specified multiple times.
#: The syntax is::

#: example - symbol_map codepoints Font Family Name

# - Use additional nerd symbols
# See https://github.com/be5invis/Iosevka/issues/248
# See https://github.com/ryanoasis/nerd-fonts/wiki/Glyph-Sets-and-Code-Points

# Seti-UI + Custom
  symbol_map U+E5FA-U+E62B Symbols Nerd Font
# Devicons
  symbol_map U+E700-U+E7C5 Symbols Nerd Font
# Font Awesome
  symbol_map U+F000-U+F2E0 Symbols Nerd Font
# Font Awesome Extension
  symbol_map U+E200-U+E2A9 Symbols Nerd Font
# Material Design Icons
  symbol_map U+F500-U+FD46 Symbols Nerd Font
# Weather
  symbol_map U+E300-U+E3EB Symbols Nerd Font
# Octicons
  symbol_map U+F400-U+F4A8,U+2665,U+26A1,U+F27C Symbols Nerd Font
# Powerline Extra Symbols
  symbol_map U+E0A3,U+E0B4-U+E0C8,U+E0CC-U+E0D2,U+E0D4 Symbols Nerd Font
# IEC Power Symbols
  symbol_map U+23FB-U+23FE,U+2b58 Symbols Nerd Font
# Font Logos
  symbol_map U+F300-U+F313 Symbols Nerd Font
# Pomicons
  symbol_map U+E000-U+E00D Symbols Nerd Font
# nonicon  
  symbol_map U+f101-U+f208 nonicon

# narrow_symbols

#: E.g. narrow_symbols U+E0A0-U+E0A3,U+E0C0-U+E0C7 1

#: Usually, for Private Use Unicode characters and some symbol/dingbat
#: characters, if the character is followed by one or more spaces,
#: kitty will use those extra cells to render the character larger, if
#: the character in the font has a wide aspect ratio. Using this
#: option you can force kitty to restrict the specified code points to
#: render in the specified number of cells (defaulting to one cell).
#: This option can be specified multiple times. The syntax is::

#:     narrow_symbols codepoints [optionally the number of cells]

disable_ligatures never

#: Choose how you want to handle multi-character ligatures. The
#: default is to always render them. You can tell kitty to not render
#: them when the cursor is over them by using cursor to make editing
#: easier, or have kitty never render them at all by using always, if
#: you don't like them. The ligature strategy can be set per-window
#: either using the kitty remote control facility or by defining
#: shortcuts for it in kitty.conf, for example::

#:     map alt+1 disable_ligatures_in active always
#:     map alt+2 disable_ligatures_in all never
#:     map alt+3 disable_ligatures_in tab cursor

#: Note that this refers to programming ligatures, typically
#: implemented using the calt OpenType feature. For disabling general
#: ligatures, use the font_features option.

# font_features

#: E.g. font_features none

#: Choose exactly which OpenType features to enable or disable. This
#: is useful as some fonts might have features worthwhile in a
#: terminal. For example, Fira Code includes a discretionary feature,
#: zero, which in that font changes the appearance of the zero (0), to
#: make it more easily distinguishable from Ø. Fira Code also includes
#: other discretionary features known as Stylistic Sets which have the
#: tags ss01 through ss20.

#: For the exact syntax to use for individual features, see the
#: HarfBuzz documentation <https://harfbuzz.github.io/harfbuzz-hb-
#: common.html#hb-feature-from-string>.

#: Note that this code is indexed by PostScript name, and not the font
#: family. This allows you to define very precise feature settings;
#: e.g. you can disable a feature in the italic font but not in the
#: regular font.

#: On Linux, font features are first read from the FontConfig database
#: and then this option is applied, so they can be configured in a
#: single, central place.

#: To get the PostScript name for a font, use `kitty +list-fonts
#: --psnames`:

#: .. code-block:: sh

#:     $ kitty +list-fonts --psnames | grep Fira
#:     Fira Code
#:     Fira Code Bold (FiraCode-Bold)
#:     Fira Code Light (FiraCode-Light)
#:     Fira Code Medium (FiraCode-Medium)
#:     Fira Code Regular (FiraCode-Regular)
#:     Fira Code Retina (FiraCode-Retina)

#: The part in brackets is the PostScript name.

#: Enable alternate zero and oldstyle numerals::

#:     font_features FiraCode-Retina +zero +onum

#: Enable only alternate zero in the bold font::

#:     font_features FiraCode-Bold +zero

#: Disable the normal ligatures, but keep the calt feature which (in
#: this font) breaks up monotony::

#:     font_features TT2020StyleB-Regular -liga +calt

#: In conjunction with force_ltr, you may want to disable Arabic
#: shaping entirely, and only look at their isolated forms if they
#: show up in a document. You can do this with e.g.::

#:     font_features UnifontMedium +isol -medi -fina -init

box_drawing_scale 0.001, 1, 1.5, 2

#: The sizes of the lines used for the box drawing Unicode characters.
#: These values are in pts. They will be scaled by the monitor DPI to
#: arrive at a pixel value. There must be four values corresponding to
#: thin, normal, thick, and very thick lines.

